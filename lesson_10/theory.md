<details>
  <summary style="cursor: pointer;"><b>English</b></summary>

# Lesson 9

General rules for naming endpoints:

1. Do not use verbs, including those denoting CRUD operations.
   Use nouns.

Bad examples:

http://api.example.com/v1/store/CreateItems/{item-id}❌
http://api.example.com/v1/store/getEmployees/{emp-id}❌
http://api.example.com/v1/store/update-prices/{price-id}❌
http://api.example.com/v1/store/deleteOrders/{order-id}❌

Good examples:

http://api.example.com/v1/store/items/{item-id}✅
http://api.example.com/v1/store/employees/{emp-id}✅
http://api.example.com/v1/store/prices/{price-id}✅
http://api.example.com/v1/store/orders/{order-id}✅

2. Don't use singular unless we are accessing a singleton resource.
   Use plural.

Bad examples (Typical and Singleton resources):

http://api.example.com/v1/store/item/{item-id}❌
http://api.example.com/v1/store/employee/{emp-id}/address❌

Good examples (Typical and Singleton resources):

http://api.example.com/v1/store/items/{item-id}✅
http://api.example.com/v1/store/employees/{emp-id}/address✅

3. Do not use camelCase, continuous spelling of words, and underscores in resource names.
   Use a hyphen.

Bad examples:

http://api.example.com/v1/store/vendormanagement/{vendor-id}❌
http://api.example.com/v1/store/itemmanagement/{item-id}/producttype❌
http://api.example.com/v1/store/inventory_management❌

Good examples:

http://api.example.com/v1/store/vendor-management/{vendor-id}✅
http://api.example.com/v1/store/item-management/{item-id}/product-type✅
http://api.example.com/v1/store/inventory-management✅

4. Don't use file name extensions.
   Just omit them.

Bad examples:

http://api.example.com/v1/store/items.json❌
http://api.example.com/v1/store/products.xml❌

Good examples:

http://api.example.com/v1/store/items✅
http://api.example.com/v1/store/products✅

5. Do not use substring for searching, filtering, sorting.
   Use parameters.

❌Wrong:

/getUsers/2/10

✔️Correct:

/users?page=2&perPage=10

6. Do not use shortened and meaningless parameter names.
   Use meaningful names.

❌Wrong:

/users?q=John
/books?search=history

✔️Correct:

/users?name=John
/books?category=history

7. Do not use different formats for the answer.
   Maintain consistency.

</details>

<hr>

<details style="padding-top: 18px">
  <summary style="cursor: pointer;"><b>На русском</b></summary>

# Lesson 9

## Общепринятые правила именования эндпоинтов (endpoint):

1. Не использовать глаголы, в том числе обозначающие CRUD-операции.
   Использовать существительные.

**Bad examples:**

http://api.example.com/v1/store/CreateItems/{item-id}❌
http://api.example.com/v1/store/getEmployees/{emp-id}❌
http://api.example.com/v1/store/update-prices/{price-id}❌
http://api.example.com/v1/store/deleteOrders/{order-id}❌

**Good examples:**

http://api.example.com/v1/store/items/{item-id}✅
http://api.example.com/v1/store/employees/{emp-id}✅
http://api.example.com/v1/store/prices/{price-id}✅
http://api.example.com/v1/store/orders/{order-id}✅



2. Не использовать единственное число, если мы не обращаемся к ресурсу-синглтону.
   Использовать множественное число.

Bad examples (Typical and Singleton resources):

http://api.example.com/v1/store/item/{item-id}❌
http://api.example.com/v1/store/employee/{emp-id}/address❌

Good examples (Typical and Singleton resources):

http://api.example.com/v1/store/items/{item-id}✅
http://api.example.com/v1/store/employees/{emp-id}/address✅



3. Не использовать camelCase, слитное написание слов и символ подчёркивания в именах ресурсов.
   Использовать дефис.

Bad examples:

http://api.example.com/v1/store/vendormanagement/{vendor-id}❌
http://api.example.com/v1/store/itemmanagement/{item-id}/producttype❌
http://api.example.com/v1/store/inventory_management❌

Good examples:

http://api.example.com/v1/store/vendor-management/{vendor-id}✅
http://api.example.com/v1/store/item-management/{item-id}/product-type✅
http://api.example.com/v1/store/inventory-management✅

4. Не использовать расширения имён файлов.
   Просто опускать их.

Bad examples:

http://api.example.com/v1/store/items.json❌
http://api.example.com/v1/store/products.xml❌

Good examples:

http://api.example.com/v1/store/items✅
http://api.example.com/v1/store/products✅



5. Не использовать подстроку для поиска, фильтрации, сортировки.
   Использовать параметры.

❌Wrong:

/getUsers/2/10

✔️Correct:

/users?page=2&perPage=10


6. Не использовать сокращённые и не несущие смысла имена параметров.
   Использовать осмысленные имена.

❌Wrong:

/users?q=John
/books?search=history

✔️Correct:

/users?name=John
/books?category=history

7. Не использовать разные форматы для ответа.
   Соблюдать единообразие.

--------------------------------------------------------------------------

## Spring Boot JPA (Java Persistence API)

Spring Boot JPA (Java Persistence API) является частью большего семейства Spring Data и предоставляет удобные инструменты для работы с базами данных в Java-приложениях. Вот основные моменты, которые помогут понять, что это такое и как это работает:

1. **Что такое Spring Boot JPA?**
   - Spring Boot JPA – это модуль в Spring Boot, который упрощает интеграцию слоя доступа к данным, используя JPA (Java Persistence API). JPA – это спецификация Java, предоставляющая стандартизированный способ управления данными в базе данных в Java-приложениях.
   - Spring Boot JPA облегчает конфигурацию и управление базами данных, автоматически настраивая JPA и упрощая создание репозиториев для взаимодействия с базой данных.

2. **Как работает Spring Boot JPA?**
   - **Автоконфигурация:** В Spring Boot автоматически конфигурируются компоненты, необходимые для работы с базой данных, такие как `EntityManagerFactory`, `DataSource` и транзакционные менеджеры. Это означает, что разработчикам не нужно тратить время на ручную настройку.
   - **Репозитории:** Spring Boot JPA позволяет создавать репозитории, интерфейсы для взаимодействия с базой данных, с минимальным количеством кода. Разработчики могут определить интерфейсы, расширяющие `JpaRepository` или другие подобные интерфейсы Spring Data, и Spring автоматически создаст их реализацию во время выполнения.
   - **Объектно-реляционное отображение (ORM):** JPA использует ORM для отображения объектов Java на таблицы базы данных, позволяя разработчикам работать с базой данных с помощью объектно-ориентированных парадигм.
   - **JPQL и SQL:** JPA позволяет использовать Java Persistence Query Language (JPQL) или нативный SQL для выполнения запросов к базе данных, давая разработчикам гибкость в выборе подхода к взаимодействию с данными.

3. **Пример использования:**
   - Предположим, у вас есть класс `User`, который вы хотите отобразить на таблицу в базе данных.
   - Вы создаёте интерфейс `UserRepository`, расширяющий `JpaRepository`, и автоматически получаете множество методов для работы с пользователями, таких как сохранение, удаление, поиск и т.д., без необходимости писать дополнительный код.

Для работы со Spring Data JPA и для определения сущностей, их связей и репозиториев, используются различные аннотации из пакетов `javax.persistence` и `org.springframework`. Вот некоторые из наиболее важных аннотаций, которые часто используются в приложениях Spring Data JPA:

1. **Аннотации сущностей:**
   - `@Entity`: Определяет класс как сущность JPA, которая должна быть отображена в таблицу базы данных.
   - `@Table`: Указывает на то, с какой таблицей в базе данных ассоциирована сущность. Можно указать имя таблицы и другие детали.
   - `@Id`: Обозначает поле класса как первичный ключ сущности.
   - `@GeneratedValue`: Определяет стратегию генерации значений для первичного ключа.
   - `@Column`: Определяет отображение поля класса на столбец таблицы в базе данных. Можно указать имя столбца, его длину, уникальность и другие параметры.
   - `@ManyToOne`, `@OneToMany`, `@OneToOne`, `@ManyToMany`: Определяют различные типы связей между сущностями.

2. **Аннотации репозитория:**
   - `@Repository`: Помечает интерфейс как репозиторий, что также помогает в обработке исключений переводя их в исключения Spring DataAccessException.
   - `@Transactional`: Определяет область, в пределах которой должна быть гарантирована целостность выполнения операций. Может быть применена к классу или методу.

3. **Дополнительные аннотации:**
   - `@Query`: Позволяет определить пользовательский запрос на языке JPQL или нативный SQL.
   - `@Param`: Указывает параметр в пользовательском запросе, обозначенном через `@Query`.
   - `@PersistenceContext`: Используется для внедрения `EntityManager` в DAO-классы.

Эти аннотации играют ключевую роль в маппинге объектов Java на таблицы базы данных и обеспечивают удобный способ взаимодействия с данными, минимизируя необходимость написания шаблонного кода.


### `@Query` и `@Param`

Аннотация `@Query` используется для определения пользовательского запроса на языке JPQL или SQL. Аннотация `@Param` используется для указания параметров в этих запросах.

```java
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import java.util.List;

public interface UserRepository extends JpaRepository<User, Long> {

    // Пример JPQL запроса с параметром
    @Query("SELECT u FROM User u WHERE u.email = :email")
    List<User> findByEmail(@Param("email") String email);

    // Пример нативного SQL запроса с параметром
    @Query(value = "SELECT * FROM users u WHERE u.name = :name", nativeQuery = true)
    List<User> findByName(@Param("name") String name);
}
```

В этом примере, `findByEmail` использует JPQL для поиска пользователей по электронной почте, а `findByName` использует нативный SQL для поиска пользователей по имени.

### Варианты запросов:

В Spring Data JPA можно использовать несколько типов запросов:

1. **JPQL (Java Persistence Query Language):** Позволяет создавать запросы, ориентированные на сущности и их отношения, а не на таблицы и столбцы базы данных.

2. **Нативный SQL (nativeQuery):** Предоставляет возможность писать прямые SQL-запросы, что может быть полезно для использования функций, специфичных для конкретной базы данных, или когда операции не могут быть легко выражены через JPQL.

3. **Методы Spring Data JPA:** Названия методов в репозиториях могут быть автоматически трансформированы в запросы без необходимости явно их указывать, например, `findByLastName(String lastName)`.

-----------------------------------------------------------------------

## Связи между сущностями

* ОО-связи
* Реляционные связи

### Рассмотрим предметную область:

* Владельцы машин
* Машины
* Водители машин (арендаторы машин)

### 01.  Реляционные связи (SQL)

#### Один-ко-многим

* Как сделать так, чтобы у машины был владелец?
* Нам необходимо у машины хранить id владельца из таблицы `account`
* Такая связь называется `Многие-к-Одному`/`Many-To-One`, `Один-ко-Многим`/`One-To-Many`
* Почему так называется? Потому что у одного владельца может быть много машин, и у многих машин только один владелец
* Чтобы гарантировать, что у машины будет указан существующий владелец, необходимо использовать внешний ключ (`foreign key`)
* `foreign key (owner_id) references account(id)` - мы говорим, что колонка `owner_id` является внешним ключом
   * Ссылается на колонку `id` в таблице `account`
   * Вы не сможете поставить в колонку `owner_id` значение, которого нет в таблице `account`

#### Многие-ко-многим

* Как сделать так, чтобы можно было обозначить, что какой-то человек водит какую-то машину, но не является владельцем
* Много человек могут "брать в аренду" много машин, и при этом много машин может быть арендовано многими людьми
* Такая связь называется `Многие-ко-многим`/`Many-to-Many`
* Ее в SQL можно реализовать с помощью третьей таблицы с двумя внешними ключами

### 02. Объектно-ориентированные связи

* А как сделать аналогию, только в приложении? Как правильно связать между собой классы?
* Важно помнить, что `класс ~ таблица`, а `объект ~ строка` таблицы.
* Как это реализуется?

#### Один-ко-многим

* В классе, который "Один", нужно сделать множество/список объектов типа "Многие"
* В классе, который "Многие", нужно сделать один объект типа "Один"

#### Многие ко многим

* В обоих классах создаем множества/списки другого типа

### 03. Реализация связей в образовательном центре

* Пользователь
   * Список курсов, на которые он записан
* Курс
   * Список уроков, которые включены в этот курс
   * Список студентов, которые включены в этот курс
* Урок
   * Курс, к которому принадлежит урок

#### Многие-к-одному/Один-ко-многим

```
@ManyToOne
@JoinColumn(name = "course_id", nullable = false)
private Course course;
```

* `@ManyToOne` - аннотация `JPA`, которой бы обозначаем связь `Многие к одному`
* `@JoinColumn` - говорим, что нужно создать внешний ключ `course_id`
* Hibernate автоматически создаст внешний ключ на таблицу с курсами.

```
@OneToMany(mappedBy = "course")
private Set<Lesson> lessons;
```

* `@OneToMany` - аннотация JPA, которая ставится в связи "Один ко многим" в сущности, которая "одна"
* `mappedBy` - означает, что в дочерней сущности (в уроке) уже прописана логика этой связи над полем `course`
   * и мы просто хотим использовать ее
* В множество `lessons` будут автоматически загружаться уроки, у которых стоит тот же `course`, что вы и запросили

#### Многие-ко-многим

```
@ManyToMany
    @JoinTable(
            name = "student_course",
            joinColumns =
            @JoinColumn(name = "student_id", nullable = false, referencedColumnName = "id"),
            inverseJoinColumns =
            @JoinColumn(name = "course_id", nullable = false, referencedColumnName = "id"),
            uniqueConstraints = @UniqueConstraint(columnNames = {"student_id", "course_id"})
    )
    private Set<Course> courses;
```

* `@ManyToMany` - обозначает связь многие-ко-многим
* `@JoinTable` - говорит о том, что нам нужна третья таблица `student_course` с двумя внешними ключами:
   * `joinColumns` - указываем первую колонку (первый внешний ключ), она не может null, называется `student_id` и ссылается на `id` таблицы `account`
   * `inverseJoinColumns` - указываем вторую колонку (второй внешний ключ), она не может быть null, называется `course_id` и ссылается на `id` таблицы `course`
   * `uniqueContstraints` - указываем колонки, которые должны быть в паре уникальными в этой таблице
* В чем разница между `joinColumns` и `uniqueContstraints`
* В `joinColumns` пишем ссылку на ту таблицу, из класса которой мы прописываем связь
* Сейчас мы описывали связь в классе `User`, поэтому первая колонка ссылается на `User`

### 04. Реализация endpoint-а для добавления урока в курс

* По правилам REST нужно endpoint назвать так:

```
POST /api/courses/{id-курса}/lessons

{
  "name": "Java - Введение",
  "startTime": "9:30",
  "finishTime": "13:00",
  "dayOfWeek": "MONDAY"
}
```

### 05. Реализация endpoint-а для получения всех уроков какого-либо курса

* По правилам REST можно endpoint назвать так:

```
GET /api/courses/{id-курса}/lessons
```

## Выводы

* Существуют связи "Многие-к-одному"/"Один-ко-многим" и "Многие-ко-многим"
* На уровне SQL-базы данных:
   * Многие-к-одному реализуются через один внешний ключ на другую таблицу
   * Многие-ко-многим с помощью третей таблицы с двумя внешними ключами
* На уровне Java-кода:
   * Многие-к-одному реализуются через `Set` в одном классе и через единственный экземпляр в другом.
   * Многие-ко-многим реализуются через `Set` в обоих классах
* Необходимо использовать соответствующие аннотации JPA для того, чтобы Hibernate мог сгенерировать необходимые таблицы и связи между ними:
   * `@OneToMany`/`@ManyToOne`/`@JoinColumn` - для один-ко-многим и многие-к-одному соответственно
   * `@ManyToMany/@JoinTable` - для многие-ко-многим
* Если мы хотим реализовать endpoint-ы для работы с этими сущностями, то их следует именовать вот так:
   * `/родительская сущность/{id-родительской сущности}/дочерняя сущность`
   * `/cars/10/drivers` - все водители машины с id = 10
   * `/drivers/5/cars` - все машины водителя с id = 5
   * `/courses/4/lessons` - все уроки четвертого курса и т.д.

-------------------------------------------------------------------------------

## LIQUIBASE

### Создание базы данных и её начальное заполнение при запуске приложения

Есть множество способов организовать создание базы данных и её начальное заполнение при запуске приложения.
Выбор метода зависит от используемых технологий и требований к проекту.

Вот некоторые из популярных подходов:

1. **Liquibase или Flyway**:
   - Если вы уже используете Liquibase (или альтернативный инструмент, такой как Flyway), можно создать специфический changeset или миграцию, который создает начальную структуру БД и добавляет начальные данные.
   - При запуске приложения Liquibase или Flyway автоматически применит эти миграции, если они ещё не были применены.

2. **Framework-специфичные инструменты**:
   - Многие современные фреймворки предоставляют механизмы для инициализации и миграции БД.
   - Например, в **Django** есть система миграций, а в **Ruby on Rails** — механизм миграций и seeds.

3. **ORM (Object-Relational Mapping)**:
   - Некоторые ORM позволяют автоматически создавать схему БД на основе определенных моделей. Например, в **Hibernate** есть свойство `hbm2ddl.auto`, которое может быть настроено на автоматическое создание или обновление схемы.
   - Многие ORM также предоставляют средства для заполнения БД начальными данными.

4. **SQL скрипты**:
   - Напишите SQL скрипты для создания таблиц и заполнения их данными, затем выполните их при первом запуске приложения.

5. **Контейнеризация и системы оркестрации**:
   - Если вы используете контейнеры, например Docker, можно настроить запуск определенных SQL скриптов или других инструментов при инициализации контейнера с БД.

6. **Приложение-инициализатор**:
   - Создайте отдельный компонент или модуль в вашем приложении, который будет проверять, инициализирована ли БД, и, если нет, создавать схему и заполнять начальными данными.

При выборе метода следует учитывать потребности проекта, инфраструктурные ограничения и ваш опыт работы с выбранными инструментами. В любом случае, перед автоматическим применением изменений к продакшен-БД рекомендуется тщательно тестировать процесс на тестовом окружении.


**Liquibase** — это инструмент для управления версиями баз данных, который позволяет следить за изменениями схемы базы данных и применять их последовательно. Основная идея заключается в том, чтобы сохранять историю изменений БД в виде последовательности миграций (changesets), которые можно применять и отменять.

**Принципы работы:**
1. **Файлы миграции**: Изменения БД описываются в специальных файлах (обычно XML, но могут быть и в форматах YAML, JSON и SQL).
2. **Changeset**: Основная единица изменения в Liquibase. Каждый changeset имеет уникальный идентификатор, который используется для отслеживания его применения к базе данных.
3. **DATABASECHANGELOG**: Таблица, создаваемая Liquibase в вашей БД, которая отслеживает, какие changesets были применены и когда.
4. **MD5 Checksums**: Liquibase создает контрольные суммы для каждого changeset, чтобы определить, изменился ли он после применения.
5. **Rollbacks**: Liquibase предоставляет возможность определить, как отменить примененный changeset, если это потребуется.

**Основные шаги для реализации миграции базы данных с помощью Liquibase:**
1. **Настройка Liquibase**: Установите Liquibase и настройте его для вашей базы данных.
2. **Создание файла миграции**: Создайте файл миграции (например, в формате XML) и опишите в нем желаемые изменения.
3. **Описание changesets**: В файле миграции определите один или несколько changesets, каждый из которых описывает определенное изменение в базе данных.
4. **Применение миграции**: Запустите Liquibase для применения changesets к вашей базе данных. При успешном применении changesets записываются в таблицу DATABASECHANGELOG.
5. **Откат миграции (если необходимо)**: Если вы допустили ошибку или хотите откатить изменения, вы можете использовать Liquibase для отката определенного changeset или группы changesets.
6. **Повторение**: По мере развития вашей базы данных вы будете добавлять новые changesets в файлы миграции и применять их с помощью Liquibase.


### changeSet

В контексте Liquibase термин "changeSet" используется для обозначения атомарного изменения в базе данных. Каждый changeSet описывает одно или несколько действий, которые нужно выполнить в базе данных, например, создать таблицу, добавить столбец или вставить данные. Liquibase отслеживает, какие changeSets были применены, чтобы гарантировать, что они выполнятся только один раз и в правильном порядке.

**Структура changeSet**

Основные атрибуты changeSet в Liquibase:

- `id`: Уникальный идентификатор в рамках файла миграции.
- `author`: Имя автора, обычно используется для идентификации того, кто создал changeSet.
- `changes`: Действия или изменения, которые нужно применить к базе данных.

**Пример changeSet в формате XML:**

```xml
<changeSet id="1" author="john_doe">
    <createTable tableName="new_table">
        <column name="id" type="int" autoIncrement="true" primaryKey="true"/>
        <column name="name" type="varchar(255)"/>
    </createTable>
</changeSet>
```

В этом примере создаётся новая таблица `new_table` с двумя столбцами: `id` и `name`. Идентификатор `id` служит первичным ключом и настроен на автоинкремент.

**Как это работает:**

1. **Проверка состояния**: Когда Liquibase выполняется, он сначала проверяет таблицу `DATABASECHANGELOG` в вашей базе данных, чтобы определить, какие changeSets уже были применены.

2. **Применение changeSets**: Если changeSet ещё не применён, Liquibase выполнит действия, описанные в нём. В приведённом выше примере Liquibase создаст новую таблицу.

3. **Регистрация изменений**: После успешного применения changeSet записывается в `DATABASECHANGELOG`, включая ID, имя автора и контрольную сумму. Это предотвращает повторное применение того же changeSet и позволяет отслеживать историю изменений.

**Откат изменений:**

Liquibase также поддерживает откат изменений. Вы можете определить, как отменить изменения в каждом changeSet, или позволить Liquibase сделать это автоматически для некоторых типов изменений. Однако не все типы изменений могут быть откачены автоматически, поэтому для некоторых changeSets вам может потребоваться явно указать, как выполнять откат.

**Пример отката:**

Для изменения, внесённого выше, откат может быть автоматическим, если Liquibase поддерживает откат данного типа изменения (создание таблицы). Для сложных изменений может потребоваться определить собственную логику отката.

Использование changeSets в Liquibase — это мощный способ управления миграциями базы данных, позволяющий разработчикам точно контролировать и версионировать изменения, вносимые в схему базы данных.

Liquibase контролирует и следит за изменениями, которые были применены к базе данных. Для этого он использует таблицу `DATABASECHANGELOG`. Каждый раз, когда Liquibase применяет `changeSet`, запись о нем добавляется в эту таблицу. Если `changeSet` уже был применен к базе данных, Liquibase пропустит его при следующем выполнении. Таким образом, дубликаты не будут добавлены.

Для того чтобы быть уверенным в том, что изменения будут применены только один раз, убедитесь, что каждый `changeSet` имеет уникальный идентификатор (`id`) и автора (`author`). Эти два атрибута вместе используются Liquibase для определения уникальности `changeSet`.

Если вы хотите вручную проверить, было ли применено определенное изменение, вы можете посмотреть в таблицу `DATABASECHANGELOG` и найти запись с соответствующим `id` и `author`.

Тем не менее, есть ситуации, когда вы можете захотеть проверить наличие определенных данных в таблице перед их добавлением. В этом случае вы можете использовать условную логику в вашем `changeSet`. Например, вы можете использовать предварительное условие (`preConditions`), чтобы проверить наличие данных перед их вставкой.

Пример:

```xml
<changeSet id="2" author="authorName">
    <!-- Precondition to check if Admin role already exists -->
    <preConditions onFail="MARK_RAN">
        <not>
            <sqlCheck expectedResult="0">SELECT COUNT(*) FROM roles WHERE name='Admin'</sqlCheck>
        </not>
    </preConditions>

    <!-- Insert roles -->
    <insert tableName="roles">
        <column name="id" value="1"/>
        <column name="name" value="Admin"/>
    </insert>
</changeSet>
```

В этом примере, если роль `Admin` уже существует, изменение будет помечено как выполненное (`MARK_RAN`), и действительные изменения в базу данных не будут внесены.

Таким образом, при использовании Liquibase, у вас уже есть встроенный механизм, который гарантирует, что каждый `changeSet` будет применен только один раз. Если вы хотите добавить дополнительные проверки, вы можете использовать `preConditions`.


</details>