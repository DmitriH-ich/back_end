<details>
  <summary style="cursor: pointer;"><b>English</b></summary>

# Lesson 13

Testing in Spring Boot is an important aspect of application development that helps ensure the reliability and quality of your code. Spring Boot provides extensive testing capabilities, including integration with frameworks such as JUnit and Mockito. Testing can be divided into several levels: unit testing, integration testing, and functional testing. For now, we will focus on unit testing of controllers using Mockito and integration testing of services and the database.

### 1. Unit testing of controllers using Mockito

For unit testing of controllers, we will use `@WebMvcTest` to load only the components required to test the controller, and `Mockito` to simulate the behavior of the services used by the controller.

### 2. Integration testing of services and the database

Integration testing verifies the interactions between different layers of the application, for example, between services and the database.
In this case, we use `@DataJpaTest` to test the repository and `@SpringBootTest` for broader integration tests.

This approach allows testing the logic of the services along with their interaction with the database, which is key for integration testing.

Note that in real applications, you may also want to use test configurations and sometimes replace real services and repositories with mocks or stubs to speed up testing and isolate the components under test.

### Annotations `@BeforeEach` and `@BeforeAll`

They are used to define methods that should be executed before tests, but with different frequencies and in different contexts.

Here are their main purposes and usage examples:

1. **@BeforeEach**:
- **Purpose**: Used to execute code before each test method in the test class.

- **Sample Uses**:
- Initialize or reset states that need to be "fresh" for each test so that tests don't affect each other.
- Create new instances of objects, clear or initialize databases, files, or other resources.
- Log or print information before each test for easy debugging.

For example, `@BeforeEach` is used to initialize a new list before each test, ensuring that changes made to the list in one test don't affect other tests.

2. **@BeforeAll**:
- **Purpose**: Used to execute code once before all tests in a class, typically to set up shared resources.
- **Sample Uses**:
- Set up complex resources, connect to a database, read configurations that are needed by all tests and don't change from test to test.
- Perform long-running operations like loading large data or complex initialization that don't need to be repeated before each test.
- Setting up static data or configuration that will be used across all tests.

For example, `@BeforeAll` can be used to implement some common initialization before all tests are executed.

Using these annotations helps keep test code organized, reusable, and maintainable, and also provides test independence and isolation.

In Mockito, the `verify()` method is used to verify that certain interactions have occurred. It is a key part of mocking, which helps to verify that a certain method has been called with certain parameters on a mock object. Here are the main uses of `verify()` in Mockito:

1. **Verifying Calls**: `verify()` can be used to verify that a method has been called on a mock. This helps to ensure that certain interactions between objects actually occur.

```java
verify(mockedList).add("one");
```

This example checks if the `add` method was called with the `"one"` argument on the `mockedList` object.

2. **Call Rate**: `verify()` allows you to check how many times a method was called. This is important to ensure that the method invocation logic is followed.

```java
verify(mockedList, times(2)).add("twice");
```

This checks that the `add` method with the `"twice"` argument was called exactly twice on the `mockedList`.

3. **Never Called**: You can also check that the method was never called using `never()`.

```java
verify(mockedList, never()).add("never added");
```

This asserts that `add` with the `"never added"` argument was never called on the `mockedList`.

4. **Order of Calls**: Mockito allows you to verify the order of method calls.

```java
InOrder inOrder = inOrder(firstMock, secondMock);
inOrder.verify(firstMock).method1();
inOrder.verify(secondMock).method2();
```

This example verifies that `method1()` was called on `firstMock` before `method2()` was called on `secondMock`.

5. **Method Arguments**: `ve

</details>

<hr>

<details style="padding-top: 18px">
  <summary style="cursor: pointer;"><b>На русском</b></summary>

# Lesson 14

Тестирование в Spring Boot — это важный аспект разработки приложений, который помогает обеспечить надежность и качество кода. Spring Boot предоставляет обширные возможности для тестирования, включая интеграцию с такими фреймворками, как JUnit и Mockito. Тестирование можно разделить на несколько уровней: модульное (unit testing), интеграционное и функциональное. Сейчас мы сосредоточимся на модульном тестировании контроллеров с использованием Mockito и на интеграционном тестировании работы с сервисами и базой данных.

### 1. Модульное тестирование контроллеров с использованием Mockito

Для модульного тестирования контроллеров мы будем использовать `@WebMvcTest` для загрузки только тех компонентов, которые необходимы для тестирования контроллера, а также `Mockito` для имитации поведения сервисов, используемых контроллером.


### 2. Интеграционное тестирование сервисов и работы с базой данных

Интеграционное тестирование проверяет взаимодействие между различными слоями приложения, например, между сервисами и базой данных.
В этом случае мы используем `@DataJpaTest` для тестирования репозитория и `@SpringBootTest` для более широких интеграционных тестов.

Этот подход позволяет тестировать логику работы сервисов вместе с взаимодействием с базой данных, что является ключевым для интеграционного тестирования.

Обратите внимание, что в реальных приложениях вам также может потребоваться использовать тестовые конфигурации и иногда подменять реальные сервисы и репозитории на моки или стабы для ускорения тестирования и изоляции тестируемых компонентов.

### Аннотации `@BeforeEach` и `@BeforeAll`

Служат для определения методов, которые должны выполняться перед тестами, но с разной частотой и в разных контекстах.
Вот их основные цели и примеры использования:

1. **@BeforeEach**:
   - **Цель**: Используется для выполнения кода перед каждым тестовым методом в тестовом классе.
   - **Примеры использования**:
      - Инициализация или сброс состояний, которые должны быть "свежими" для каждого теста, чтобы тесты не влияли друг на друга.
      - Создание новых экземпляров объектов, очистка или установка начальных значений для баз данных, файлов или других ресурсов.
      - Логирование или вывод информации перед каждым тестом для удобства отладки.

   Например `@BeforeEach` используется для инициализации нового списка перед каждым тестом, гарантируя, что изменения, внесенные в список в одном тесте, не повлияют на другие тесты.

2. **@BeforeAll**:
   - **Цель**: Используется для выполнения кода один раз перед всеми тестами в классе, обычно для настройки общих ресурсов.
   - **Примеры использования**:
      - Настройка сложных ресурсов, подключение к базе данных, чтение конфигураций, которые нужны для всех тестов и не изменяются от теста к тесту.
      - Выполнение длительных операций, таких как загрузка больших данных или комплексная инициализация, которые не нужно повторять перед каждым тестом.
      - Установка статических данных или конфигураций, которые будут использоваться во всех тестах.

   Например `@BeforeAll` может использоваться для реализации какой-либо общей инициализации перед выполнением всех тестов.

Использование этих аннотаций помогает поддерживать код тестов организованным, повторно используемым и легким для поддержки, а также обеспечивает независимость и изоляцию тестов.

В Mockito, метод `verify()` используется для проверки того, что определённые взаимодействия произошли. Это ключевая часть мокирования, которая помогает проверить, был ли вызван определённый метод с определёнными параметрами на мок-объекте. Вот основные аспекты использования `verify()` в Mockito:

1. **Проверка вызовов**: С помощью `verify()` можно проверить, был ли вызван метод на моке. Это помогает удостовериться, что определённые взаимодействия между объектами действительно происходят.

   ```java
   verify(mockedList).add("one");
   ```

   В этом примере проверяется, был ли вызван метод `add` с аргументом `"one"` на объекте `mockedList`.

2. **Частота вызовов**: `verify()` позволяет проверить, сколько раз был вызван метод. Это важно для убеждения в том, что логика вызовов методов соблюдается.

   ```java
   verify(mockedList, times(2)).add("twice");
   ```

   Здесь проверяется, что метод `add` с аргументом `"twice"` был вызван ровно два раза на `mockedList`.

3. **Никогда не вызывался**: Можно также проверить, что метод никогда не был вызван с использованием `never()`.

   ```java
   verify(mockedList, never()).add("never added");
   ```

   Это утверждает, что `add` с аргументом `"never added"` никогда не вызывался на `mockedList`.

4. **Порядок вызовов**: Mockito дает возможность проверить порядок вызовов методов.

   ```java
   InOrder inOrder = inOrder(firstMock, secondMock);
   inOrder.verify(firstMock).method1();
   inOrder.verify(secondMock).method2();
   ```

   В этом примере проверяется, что `method1()` был вызван на `firstMock` до вызова `method2()` на `secondMock`.

5. **Аргументы методов**: `verify()` также можно использовать для проверки аргументов, переданных в метод. Mockito предоставляет различные методы, такие как `eq()`, `any()`, для проверки аргументов.

Использование `verify()` в тестах значительно упрощает проверку взаимодействия между объектами, что делает тесты более понятными и надёжными.

Тестирование контроллеров в Spring Boot обычно включает использование фреймворка `MockMvc`, который позволяет отправлять HTTP-запросы на контроллеры и проверять ответы без запуска полноценного сервера. Вот подробное объяснение основных методов и подходов, используемых при тестировании контроллеров:

### 1. Инициализация `MockMvc`

- **`MockMvcBuilders.standaloneSetup`**: Этот метод используется для создания конфигурации `MockMvc` для тестирования одного или нескольких контроллеров в изоляции от остальной части приложения.
- Преимущество этого подхода заключается в скорости и простоте, так как не требуется загружать полный контекст Spring.
- Этот метод идеально подходит для модульного тестирования, где фокус делается на функциональности конкретного контроллера.

- **`MockMvcBuilders.webAppContextSetup`**: В отличие от `standaloneSetup`, этот метод требует загрузки полного веб-контекста приложения, что делает его подходящим для интеграционных тестов,
- когда необходимо убедиться во взаимодействии компонентов приложения.


1.	@WebMvcTest — для тестирования контроллера с использованием подготовленного MVC контекста. Эта аннотация ограничивает загрузку контекста только тем, что необходимо для тестирования MVC (контроллеры, MVC-компоненты).
2.
3. @SpringBootTest — загружает полный контекст приложения, что используется для более комплексных интеграционных тестов.
   Если ваша цель — проверить валидацию в контроллере, вам стоит выбрать один из подходов. Для проверки взаимодействия с контроллерами и правильной валидации входящих данных можно использовать @WebMvcTest вместе с @AutoConfigureMockMvc для полноценного тестирования контроллеров без загрузки всего контекста приложения.


### 2. Конфигурация тестов

- **`@SpringBootTest`**: Эта аннотация используется для загрузки полноценного контекста приложения и часто применяется в интеграционных тестах. Она подходит для проверки реального поведения приложения в среде, максимально приближенной к продуктивной.
- **`@WebMvcTest`**: Специализированная аннотация для тестирования MVC контроллеров, которая загружает только необходимые для контроллера компоненты, такие как конвертеры, валидаторы и контроллеры, без запуска полного контекста Spring.

### 3. Настройка и использование `MockMvc`

- **`.perform(RequestBuilder requestBuilder)`**: Основной метод для отправки HTTP-запросов на контроллер. `RequestBuilder` может быть создан с помощью статических методов `MockMvcRequestBuilders`, таких как `get()`, `post()`, `put()`, `delete()` и т.д., для имитации соответствующих HTTP-запросов.
- **`.andExpect(ResultMatcher matcher)`**: Метод для проверки ответов контроллера. `ResultMatcher` позволяет проверить статус ответа, содержимое ответа, заголовки и другие аспекты HTTP-ответа. Эти матчеры обычно создаются с помощью статических методов класса `MockMvcResultMatchers`.

### 4. Проверка результатов

- **`status()`**: Проверяет статус HTTP-ответа. Например, можно проверить, был ли ответ успешным (`isOK()`), привел ли к ошибке клиента (`isBadRequest()`) или сервера (`isServerError()`).
- **`jsonPath(String expression, Matcher<?> matcher)`**: Используется для проверки конкретных данных в JSON-ответе. JsonPath — это выражение, указывающее на конкретные части JSON-документа. Например, можно проверить, содержит ли поле `name` в ответе ошибку валидации.

### 5. Обработка исключений и мокирование

- **`@MockBean`**: Аннотация используется для добавления моков в контекст Spring теста. Это позволяет заменить реальные бины на их подделки, что особенно полезно для контроля поведения зависимостей в тестах.
- **`when()` и `thenReturn()`**: Методы из библиотеки Mockito, которые используются для задания поведения моков. Например, можно настроить мок сервиса так, чтобы при вызове метода возвращалось исключение или специфический результат, что позволяет тестировать различные сценарии поведения контроллера при разных условиях.

Использование этих методов и подходов позволяет гибко настраивать тестирование контроллеров в Spring Boot, обеспечивая как широкое покрытие функциональности, так и детализированную проверку каждого аспекта взаимодействия клиента с сервером.

Тестирование контроллеров в Spring Boot часто включает использование `MockMvc`, позволяющего проводить HTTP-запросы без полного сервера.
Вот ключевые элементы:

1. **Инициализация `MockMvc`**:
   - `MockMvcBuilders.standaloneSetup` для изолированного тестирования контроллеров. Это быстро и удобно для модульных тестов.
   - `MockMvcBuilders.webAppContextSetup` загружает полный веб-контекст, подходит для интеграционных тестов.

2. **Аннотации**:
   - `@SpringBootTest` загружает полный контекст приложения, идеально для проверки реального поведения.
   - `@WebMvcTest` загружает только нужное для тестирования MVC, что ускоряет и упрощает процесс.

3. **Методы `MockMvc`**:
   - `.perform(RequestBuilder requestBuilder)` отправляет запросы.
   - `.andExpect(ResultMatcher matcher)` проверяет ответы, позволяя анализировать статус, содержимое и заголовки.

4. **Проверка результатов**:
   - `status()` проверяет HTTP-статус ответа.
   - `jsonPath(String expression, Matcher<?> matcher)` анализирует JSON-ответы для проверки конкретных данных.

5. **Мокирование и обработка исключений**:
   - `@MockBean` для добавления моков в контекст, что позволяет заменять реальные бины на подделки для контроля зависимостей.
   - `when()` и `thenReturn()` из Mockito настраивают поведение моков.

Эти методы и подходы предоставляют гибкость в тестировании, обеспечивая как детальную проверку каждого аспекта, так и широкое покрытие функциональности. Это позволяет тестировать как отдельные функции контроллеров, так и их взаимодействие в рамках всего приложения.

Давайте подробно разберем комментарии к коду для каждого класса и метода, приведенных в вашем примере, а также добавим аннотации и объяснения к стандартным классам и аннотациям.

### Общие аннотации и стандартные классы

1. **@SpringBootTest**:
   - Эта аннотация указывает, что контекст тестирования должен быть загружен как `Spring Boot` приложение. Это обеспечивает загрузку полной конфигурации и подходит для интеграционного тестирования.

2. **@AutoConfigureMockMvc**:
   - Автоматически настраивает `MockMvc`, который используется для отправки запросов в тестовый `Spring MVC` контроллер. Это удобно для тестирования веб-слоя без запуска сервера.

3. **@AutoConfigureTestDatabase**:
   - Заменяет базу данных приложения на встраиваемую базу данных (например, H2) для тестирования, что ускоряет выполнение тестов и делает их более предсказуемыми.

4. **@ActiveProfiles("test")**:
   - Задает профиль Spring, который должен быть активирован во время тестирования. Это позволяет использовать специфичные для тестирования настройки.

5. **@TestPropertySource**:
   - Указывает на местоположение файлов свойств, которые должны быть загружены для тестов.

6. **@WithMockUser**:
   - Эта аннотация используется для эмуляции аутентификации пользователя в тестах безопасности.



## `@SpringTest`, `@ActiveProfiles`

### 1. Введение в Spring Test и аннотацию @SpringBootTest
**Тезис**: `@SpringBootTest` предоставляет поддержку загрузки ApplicationContext и предназначена для интеграционного тестирования в Spring Framework.
**Комментарий**:
- `@SpringBootTest` используется для эмуляции полной работы приложения, позволяя тестировать его в условиях, максимально приближенных к реальным.
- Эта аннотация позволяет инжектировать зависимости и использовать все бины Spring, делая тесты комплексными и всесторонними.
- Важно понимать, что использование `@SpringBootTest` может значительно увеличить время выполнения тестов из-за загрузки полного контекста приложения.
- Аннотация подходит для сценариев, где необходимо проверить взаимодействие компонентов системы, например, работы сервисов с базой данных или интеграции между различными модулями.
- При использовании `@SpringBootTest` можно задать конкретный класс конфигурации через атрибут `classes`, что позволяет более гибко управлять контекстом тестирования.

### 2. Профилирование тестов с помощью @ActiveProfiles
**Тезис**: Аннотация `@ActiveProfiles` позволяет задать профили Spring, которые будут активны во время выполнения тестов.
**Комментарий**:
- `@ActiveProfiles` используется для указания конкретных профилей настроек, которые должны быть активны во время тестирования, позволяя имитировать различные условия окружения.
- Это особенно полезно для тестирования приложений, поведение которых может отличаться в зависимости от окружения, например, различия в конфигурациях для разработки и продакшена.
- С помощью `@ActiveProfiles` можно тестировать специфические компоненты, настроенные под определенные условия, не изменяя основной код приложения.
- Профили могут управлять параметрами подключения к базам данных, настройками безопасности или конфигурациями специфических бинов.
- Эта аннотация часто используется совместно с `@SpringBootTest` для точного контроля над тестовым окружением.

### 3. Конфигурация тестов и тестирование с использованием базы данных в памяти
**Тезис**: Использование баз данных в памяти для тестирования позволяет избежать зависимостей от внешних систем и ускорить выполнение тестов.
**Комментарий**:
- Базы данных в памяти, такие как H2, предоставляют легковесную и быструю альтернативу традиционным базам данных, что идеально подходит для тестирования.
- Тесты, использующие базы данных в памяти, могут выполняться изолированно и не влияют на продуктивную базу данных или состояние других тестов.
- Важно правильно настроить контекст Spring, чтобы он использовал базу

данных в памяти во время тестов, что обычно достигается путем настройки соответствующего профиля или конфигурации тестов.
- Можно использовать такие инструменты, как Flyway или Liquibase, для инициализации схемы БД перед запуском тестов, что обеспечивает консистентность и воспроизводимость результатов.
- Тестирование с базой данных в памяти часто сочетается с использованием `@DataJpaTest` или `@JdbcTest` для сегментирования тестирования репозиториев или JDBC операций.

### 4. Интеграционное тестирование контроллеров с использованием @WebMvcTest
**Тезис**: `@WebMvcTest` предназначена для интеграционного тестирования веб-контроллеров в изоляции от остального Spring ApplicationContext.
**Комментарий**:
- `@WebMvcTest` заботится только о слое веб-контроллеров, загружая минимально необходимый контекст, что делает тесты быстрыми и фокусированными.
- Эта аннотация автоматически настраивает Spring MVC инфраструктуру для тестирования и позволяет легко инжектировать моки для сервисов, используемых контроллерами.
- Тесты с использованием `@WebMvcTest` должны фокусироваться на взаимодействии контроллера с запросами и ответами, а также на корректности вызовов методов сервисов.
- Для проверки возвращаемых значений и статусов ответов можно использовать Spring MVC Test Framework, который предоставляет удобные абстракции, например, `MockMvc`.
- Хотя `@WebMvcTest` отлично подходит для тестирования контроллеров, важно помнить, что она не загружает полный контекст приложения, и это может привести к непредвиденным результатам, если контроллеры взаимодействуют с другими компонентами, не включенными в тестовый контекст.

</details>